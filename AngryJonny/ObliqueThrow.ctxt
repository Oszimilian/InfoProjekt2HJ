#BlueJ class context
comment0.target=ObliqueThrow
comment1.params=myWorld\ scoreBoardObject
comment1.target=ObliqueThrow(MyWorld,\ ScoreBoard)
comment1.text=\r\n\ \ \ Konstruktor\ speichert\ Referenz\ zur\ MyWorld-Klasse\r\n
comment10.params=pitch\ calcStartX
comment10.target=double\ slideToPoint(double,\ double)
comment10.text=\r\n\ \ \ Diese\ Methode\ berechnet\ die\ X-Verschiebung\ der\ neuen\ Funktion,\ um\ eine\ Funktion\ mit\ der\ negierten\ steigung\ tangential\ durch\ den\ Abprall\ punkt\ laufen\ zu\ lassen\r\n
comment11.params=
comment11.target=void\ calcObliqueThrow()
comment11.text=\r\n\ \ \ Berechnung\ der\ Wurf-Funktion\r\n\ \ \ kann\ durch\ "direction"\ den\ Wurf\ in\ beide\ richtungen\ ablaufen\ lassen\r\n\ \ \ Mit\ den\ Statischen\ Methoden\ boardStartX\ und\ boardStartY\ wird\ der\ reale\ Punkt\ auf\ dem\ Spielfeld\ errechnet\ \r\n\ \ \ Durch\ Typcasting\ und\ eine\ Referenz\ auf\ das\ Ballobjekt\ wird\ die\ Position\ des\ Balles(Objekt)\ gesetz\r\n
comment12.params=
comment12.target=void\ startThrow()
comment12.text=\r\n\ \ \ Diese\ Methode\ wird\ durch\ das\ loslassen\ der\ Taste\ "a"\ aufgerufen\ und\ leitet\ den\ Abwurf\ ein\r\n\ \ \ aufruf\ dieser\ Methode\ befindet\ sich\ in\ EnergyDisplay\r\n
comment13.params=reference
comment13.target=void\ transmitReference(Object)
comment13.text=\r\n\ \ \ Jedes\ Mal\ wenn\ ein\ neues\ Abprallobject\ erzeugt\ wird,\ wird\ durch\ den\ Aufruf\ dieser\ Funktion\ die\ entsprechende\ Referenz\ dieses\ Objektes\ in\ einem\ neuen\ Array-Platz\ gespeichert\r\n
comment14.params=
comment14.target=void\ startNewMotion()
comment14.text=\r\n\ \ \ Startet\ einen\ neuen\ Wurf,\ bzw.\ stellt\ die\ Startbedingungen\ f\u00FCr\ einen\ neuen\ Wurf\ w\u00E4hrend\ der\ Laufzeit\ her.\r\n
comment15.params=
comment15.target=void\ stopMotion()
comment15.text=\r\n\ \ \ Stopt\ die\ Bewegung\ des\ Wurfes\r\n
comment2.params=
comment2.target=void\ act()
comment2.text=\r\n\ \ \ polling\ der\ Hauptmethoden\ (permanentes\ aufrufen)\r\n
comment3.params=
comment3.target=void\ throwHandling()
comment3.text=\r\n\ \ \ Methode\ k\u00FCmmert\ sich\ darum\ zwischen\ den\ drei\ m\u00F6glichen\ Szenarien\ der\ Ballbewegung\ umzuschalten\r\n\ \ \ 1.\ Abwurfbewegung\ \ 2.\ Bewegung\ nach\ Rechts\ (nach\ Abprallen)\ \ \ 3.\ Bewegung\ nach\ links\ (nach\ Abprallen)\r\n
comment4.params=
comment4.target=void\ objectBounceDetection()
comment4.text=\r\n\ \ \ Methode\ fragt\ ab\ ob\ der\ Ball\ eines\ der\ plazierten\ Objekte\ ber\u00FChrt\r\n\ \ \ Das\ Ganze\ kommt\ in\ einem\ Exception\ block,\ da\ es\ vorkommen\ kann,\ das\ ein\ NullPointer\ entsteht\ \:(\r\n
comment5.params=
comment5.target=void\ bounceDetection()
comment5.text=\r\n\ \ \ Diese\ Methode\ \u00FCberpr\u00FCft\ ob\ der\ Ball\ Den\ Boden/Decke\ oder\ die\ zwei\ Seitenw\u00E4nde\ ber\u00FChrt.\r\n\ \ \ Ist\ dies\ der\ Fall\ wird\ per\ Methodenaufruf\ die\ Bewegungsrichtung\ f\u00FCr\ die\ n\u00E4chste\ Flugkurfe\ ge\u00E4ndert\r\n
comment6.params=
comment6.target=void\ changeDirection()
comment6.text=\r\n\ \ \ Diese\ Methode\ wechselt\ beim\ Aufruf\ der\ Funktion\ den\ boolean-WERT\ von\ direction\ um\ die\ Wurfrichtung\ zu\ \u00E4ndern.\ (Abprallen\ und\ so)\r\n
comment7.params=
comment7.target=double\ valueAtThrow()
comment7.text=\r\n\ \ \ Diese\ Methode\ berechnet\ den\ f(x)-Wert\ im\ Abprallpunkt\r\n
comment8.params=valueAtThrow\ deltaX
comment8.target=double\ throwHight(double,\ double)
comment8.text=\r\n\ \ \ Diese\ Methode\ berechnet\ die\ h\u00F6he\ des\ Abwurfes\ der\ neuen\ Abprallfunktion\r\n
comment9.params=deltaX
comment9.target=double\ deriveAtPoint(double)
comment9.text=\r\n\ \ \ Diese\ Methode\ berechnet\ die\ Steigung\ im\ Abprallpunkt\ der\ Funktion,\ um\ sp\u00E4ter\ eine\ Funktion\ mit\ genau\ der\ negierten\ Steigung\ in\ diesem\ Punkt\ zu\ bilden\r\n
numComments=16
